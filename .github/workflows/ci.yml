name: Build & Tests

on:
  pull_request:
  merge_group:

permissions: read-all

jobs:
  build_test:
    runs-on: ubuntu-latest
    # Generate and populate the global Cargo registry and cache first. Each
    # job in the matrix runs in parallel, so without populating the cache
    # first, most jobs would duplicate the work of downloading crates from
    # the internet. Populating the cache first ensures that this work only
    # happens once.
    needs: generate_cache
    name: simple-test
    steps:
    - uses: actions/checkout@eef61447b9ff4aafe5dcd4e0bbf5d482be7e7871 # v4.2.1

    - name: Run cargo test
      uses: actions-rs/cargo@v1
      with:
        command: test

  generate_cache:
    runs-on: ubuntu-latest
    name: Generate cache
    steps:
      - uses: actions/checkout@eef61447b9ff4aafe5dcd4e0bbf5d482be7e7871 # v4.2.1

      - name: Populate cache
        id: populate-cache
        uses: ./.github/actions/cache
      
      - name: dummy
        needs: populate-cache
        run: |
          echo "Cache Hit: ${{ needs.populate-cache.outputs.cache-hit }}"

      - name: Download dependencies
        if: steps.populate-cache.outputs.cache-hit != 'true'
        run: |
          # Ensure all dependencies are downloaded - both for our crates and for
          # tools we use in CI. We don't care about these tools succeeding for
          # two reasons: First, this entire job is best-effort since it's just a
          # performance optimization. Second, there may be failures due to
          # issues other than failing to download dependencies (e.g., `cargo
          # metadata` called with a malformed `Cargo.toml`, build failure in our
          # own crate or in dependencies, etc). For those reasons, we discard
          # stderr and ignore status codes.
          #
          # For downloading our crates' dependencies in particular, note that
          # there is no support for doing this directly [1], so we just check
          # all crates using --tests.
          #
          # We background all jobs and then wait for them so that they can run
          # in parallel.
          #
          # [1]  https://stackoverflow.com/a/42139535/836390

          # See comment on "Pin syn dependency" job for why we do this. It needs
          # to happen before the subsequent `cargo check`, so we don't
          # background it.
          #
          # TODO(#1595): Debug why this step is still necessary after #1564 and
          # maybe remove it.
          echo "hey this is the installation"
          cargo metadata                             &> /dev/null &
          cargo install cargo-readme --version 3.2.0 &> /dev/null &
          cargo install --locked kani-verifier       &> /dev/null &
          cargo install cargo-nextest                &> /dev/null &

          wait